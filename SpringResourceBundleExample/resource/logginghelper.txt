define LoggingInterceptor
Add to applicationcontext.xml
	<bean id="loggingInterceptor"
		class="com.bt.MGWay.utils.LoggingInterceptor" />
		

create base DAO service
	<bean id="BaseInterceptor" abstract="true"
		class="org.springframework.aop.framework.ProxyFactoryBean">
		<property name="interceptorNames">
			<list>
				<value>loggingInterceptor</value>
			</list>
		</property>
	</bean>
	
	Add this as a parent to the applicable beans.
	
	
	CommonUtils.java
	public final static MGWayException setExceptionMessage(
      final MGWayException exception) {

    final String METHOD_NAME = "setExceptionMessage";
    LOGGER.logInfo(METHOD_NAME, "Enter");
    try {
      final String exceptionCode = exception.getExceptionCode();
      if (exceptionCode != null) {
        String message = PropertyReader.getMessageProperty(exceptionCode);
        if (!((message == null) || (exception.getMessageParameters() == null))) {
          message = MessageFormat.format(message, exception
              .getMessageParameters());
        }
        exception.setExceptionMessage(message);

        final StringWriter sw = new StringWriter(2000);
        final PrintWriter pw = new PrintWriter(sw);
        exception.printStackTrace(pw);
        exception.setDetailMessage(sw.getBuffer().toString());
      }
    } catch (final Exception e) {
      LOGGER.logError("setExceptionMessage", e);
    }
    LOGGER.logInfo(METHOD_NAME, "Exit");
    return exception;
  }
  
  
  
  LoggingInterceptor.java
  
  package com.bt.mgway.util;

import java.io.Serializable;
import java.lang.reflect.Method;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.aop.AfterReturningAdvice;
import org.springframework.aop.MethodBeforeAdvice;
import org.springframework.aop.ThrowsAdvice;

import com.bt.MGWay.exception.MGWayException;


public class LoggingInterceptor implements MethodBeforeAdvice,
    AfterReturningAdvice, ThrowsAdvice, Serializable {

  private static final long serialVersionUID = 1L;
  
  /**
   * Log file reference for logging the events
   */
  private static Log log = null;

  /**
   * Method which will be invoked to log the events before execution of any
   * method.
   * 
   * @param methodname Name of method to be logged
   * @param methodArgs Arguments passed to the method
   * @param returnValue Object returned from the method
   * @throws Throwable
   */
  public void before(Method methodname, Object[] methodArgs, Object returnValue)
      throws Throwable {
    // Creating log object for logging
    log = LogFactory.getLog(returnValue.getClass());
    StringBuffer strLog = new StringBuffer().append("[Method : "
        + methodname.getName() + "(");
    // Log each of the method argument
    for (int i = 0; i < methodArgs.length; i++) {
      // If argument is not null
      if ((methodArgs[i] != null)) {
        // Log method name and argument value
        strLog.append("'" + methodArgs[i]
            + "'" + ",");
      } else {
        strLog.append(null + ",");
      }
    }
    if (strLog.toString().contains(",")) {
      strLog.substring(0, strLog.lastIndexOf(","));
    }
    strLog.append(")][Enter]");
    log.info(strLog.toString());
  }

  /**
   * Method which will be invoked to log the events after execution of any
   * method
   * 
   * @param returnValue Object returned from the method
   * @param methodname Name of method to be logged
   * @param methodArgs Arguments passed to the method
   * @param target Class where the method was called
   * @throws Throwable
   */
  public void afterReturning(Object returnValue, Method methodname,
      Object[] methodArgs, Object target) throws Throwable {

    // Creating log object for logging
    log = LogFactory.getLog(target.getClass());
    // Log return value of method
    if (returnValue != null) {
      log.info("[Method : " + methodname.getName()
          + "(" + "'"
          + returnValue + "'"
          + ")][Exit" + "]");
    } else {
      log.info("[Method : " + methodname.getName()
          + "(" + null
          + ")][Exit" + "]");
    }
  }

  /**
   * Method which will be invoked to log the events after exception has been
   * thrown
   * 
   * @param method Method in which exception occurred
   * @param methodArgs Arguments passed to the method
   * @param target Class where the method was called
   * @param exception Exception object thrown
   */
  public void afterThrowing(Method method, Object[] methodArgs, Object target,
      Throwable throwable) {
    // Creating log object for logging
    log = LogFactory.getLog(target.getClass());
    MGWayException excep = null;
    try {
      throw throwable;
    } catch (MGWayException be) {
      excep = be;
    } catch (Throwable bre) {
      excep = new MGWayException("Error occurred while processing", bre);
    }
    WebCommonUtil.setExceptionMessage(excep);
    // Log method name and exception message
    log.error("Exception in method: "+ method.getName()
        + " Exception is: " + excep.getExceptionMessage());
  }

}

	
	